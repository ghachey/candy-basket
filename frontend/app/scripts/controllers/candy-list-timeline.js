/* global _ */'use strict';/** * @ngdoc function * @name nasaraCandyBasketApp.controller:CandyListTimeline * @description * # CandyListTimeline * Controller of the nasaraCandyBasketApp contains the logic to power the  * candy list in timeline mode. *  * Notes on TimelineJS Slides and Mechanism * ---------------------------------------- *   * To change the slide of the TimelineJS it suffices to change the * state of $scope.timelineValues.index, see {@link * nasaraCandyBasketApp.stateTracker} for the related service details. * This $scope.timelineValues.index as two way bindings with the * angular-timelinejs directive, and *it* will take care of changing * the slides of the instantiates TimelineJS. This value can be force * changed anytime in the controller through $scope.changeSlide * callback, in fact this is how the "go to start" and "go to end" * buttons work. * * TODO - This controller is very similar to the CandyListTimeline controller * and they could both be merged into an Javascript prototype * only adding properties as they differ eliminating  * much code duplication and future errors. */angular.module('nasaraCandyBasketApp')  .controller('CandyListTimeline', function ($scope,                                              $location,                                              $filter,                                              CandyResource,                                              tagsViews,                                              stateTracker,                                              utilities) {    var tagsMap          = [];    var timelineItems    = [];    var now               = new Date();    var ranges            = {      'day'   : 1000 * 3600 * 24,      'week'  : 1000 * 3600 * 24 * 7,      'month' : 1000 * 3600 * 24 * 30,      'year'  : 1000 * 3600 * 24 * 365    };    $scope.candies        = [];    $scope.timelineValues = stateTracker.state.timelineValues; // i.e. {index: 0}    $scope.changeSlide = function (index) {      console.log('Changing slide index to: ', index);      $scope.timelineValues.index = index;    };    // These should be set-able, storable via the UI    // Additionally, I'd like us to think about how to set the default $scope.min,    // and $scope.max dates in to the first and last candy dates. Currently, there's    // a double bug, wherein $scope.min is set too far in the past, and $scope.max is    // set to Date.now(), which allows the user to pull up an empty data set    // (and throw an unhandled exception in the bargain).    $scope.min = now - ranges.year;    $scope.max = Date.now();    $scope.step = ranges.day;    $scope.interval = ranges.month * 2;    $scope.cutoff = now - (ranges.month * 6); //$scope.min    $scope.setDates  = function(){      var dateVal    = new Date($scope.cutoff);      var options = {year: 'numeric', month: 'long', day: 'numeric'};      var dateString = dateVal.toLocaleString('en-GB', options);      return 'Restrict results to candies created since: <br /><strong>' + dateString + '</strong>';    };    $scope.slideStart = function (event, ui){      // noop      console.log(event, ui);      return;    };    $scope.slideStop = function (event, ui){      console.log(event, ui);      var newMap = [];      tagsMap.forEach(function(elem) {        if (_.isEqual(_.intersection($scope.tags, elem.tag), $scope.tags)) {          newMap.push(elem);        }      });      if (newMap.length){        //$scope.tagsData = utilities.getTagsData(newMap, $scope.cutoff); // reduce cloud        //$scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(newMap, $scope.cutoff));        $scope.tagsData = utilities.getTagsData(newMap); // reduce cloud        $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(newMap));        $scope.changeSlide(0);        $scope.timelineData = processTimeline();      }      else {        // $scope.tagsData = utilities.getTagsData(tagsMap, $scope.cutoff); // restore cloud        // $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsMap, $scope.cutoff));        $scope.tagsData = utilities.getTagsData(tagsMap); // restore cloud        $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsMap));      }    };    $scope.slideMove = function(event, ui) {      console.log('Slide move ui: ', ui);      console.log('Slide mode event: ', event);      $scope.cutoff = ui.value;    };    $scope.displayPercentages = function(){      var confirm = '', challenge = '', surprise = '';      if (typeof $scope.ccsTagStatus === 'undefined' ||           $scope.ccsTagStatus.length === 0){        return 'Calculating...';      }      $scope.ccsTagStatus.forEach(function(thisStatus){        switch (thisStatus.type){        case 'success':	  confirm = '<span class="confirm ccs">Confirm</span>&nbsp;' + thisStatus.value + '%';	  break;        case 'danger':	  challenge = '<span class="challenge ccs">Challenge</span>&nbsp;' + thisStatus.value + '%';	  break;        case 'warning':	  surprise = '<span class="surprise ccs">Surprise</span>&nbsp;' + thisStatus.value + '%';	  break;        }      });      return [confirm,challenge,surprise].join('<br />');    };    CandyResource.query().$promise.then(function(data) {      //data.sort(compareByDates);      $scope.candies = data;      $scope.timelineData = processTimeline();    }, function(errorMessage){      $scope.error=errorMessage;    });    $scope.$on('model-update', function(){      CandyResource.query(function(data){        $scope.candies = data;        $scope.timelineData = processTimeline();      });      tagsViews.getTagsByCandies(function(response) {        // Reset mapping of candy IDs and their tags on        // broadcasted created and update events        tagsMap = response.data.tagsByCandies;        // Perform reduce with new mapping        $scope.tagsData = utilities.getTagsData(tagsMap);        $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsMap));      });      console.log('INDEX on model update: ', $scope.timelineValues.index);      $scope.changeSlide($scope.timelineValues.index);    });    var processTimeline = function() {      // Seems data should not be needed here. $scope.data on the controller      // can be used but won't refactor this just yet.      //console.debug('Data: ', data);       timelineItems = [];      var candies    = [];      var minDate   = new Date();      var maxDate   = new Date(1990); // ensure we get a real maximum from the set      //candies = $filter('candiesByTags')($scope.candies, $scope.tags, $scope.cutoff);      candies = $filter('candiesByTags')($scope.candies, $scope.tags);      candies.forEach(function(thisCandy){        var compDate  = new Date(Date.parse(thisCandy.date));        var tag       = _.find(thisCandy.tags, function(i) {          return i === 'confirm' || i === 'challenge' || i === 'surprise';        });        var candyTags = thisCandy.tags;        minDate       = minDate < compDate ? minDate : compDate;        maxDate       = maxDate < compDate ? compDate : maxDate;        timelineItems.push(          {            '_id'      : thisCandy._id,            'startDate': thisCandy.date,            'headline' : thisCandy.title,            'text'     : candyTags + '|ENDTAGS|' + thisCandy.description,            'tag'      : tag,            'asset'    : {'media': thisCandy.source}          }        );      });      var numCandies = utilities.pluralise(candies.length.toString() +                                            ' candy', 'candies');      var timelineData = {        'timeline':        {          'headline'       : numCandies + ' in this basket ',          'type'           : 'default',          'text'           : '<p>Here is a timeline of your results...</p>',          'date'           : timelineItems,          'era': [            {              'startDate': minDate,              'endDate': maxDate,              'headline': 'Story duration',              'text': '<p>hmmm</p>'            }          ]        }      };            return timelineData;    };    $scope.$watchCollection('tags', function(newSearch) {      var newMap = [];      tagsMap.forEach(function(elem) {        if (_.isEqual(_.intersection(newSearch, elem.tag), newSearch)) {          newMap.push(elem);        }      });      if (newMap.length){        // $scope.tagsData = utilities.getTagsData(newMap, $scope.cutoff); // reduce cloud        // $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(newMap, $scope.cutoff));        $scope.tagsData = utilities.getTagsData(newMap); // restore cloud        $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(newMap));        // Explicit reset to 0 when searching. otherwise, reload of new timelineData        // will be with the current slide index        $scope.changeSlide(0);        $scope.timelineData = processTimeline();      }      else {        // $scope.tagsData = utilities.getTagsData(tagsMap, $scope.cutoff); // restore cloud        // $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsMap, $scope.cutoff));        $scope.tagsData = utilities.getTagsData(tagsMap); // restore cloud        $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsMap));      }    });    $scope.tagOnClickFunction = function(element){      if (!_.contains($scope.tags, element.text)) {        $scope.tags.push(element.text);        // TODO - $apply should really be pushed to relevant directive somehow        $scope.$apply();      }    };    tagsViews.getTagsByCandies().then(function(response) {      // Initial mapping of candy IDs and their tags as they come      // out of the REST service.      tagsMap = response.data.tagsByCandies;      // Initialise tagsData (i.e. tag mapping reduced to unique      // tags and tag counts) attached to scope for two-way binding      // $scope.tagsData = utilities.getTagsData(tagsMap, $scope.cutoff);      // $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsMap, $scope.cutoff));      $scope.tagsData = utilities.getTagsData(tagsMap); // restore cloud      $scope.ccsTagStatus = utilities.updateStatusCount(        utilities.getTagsData(tagsMap));    }, function(errorMessage){      $scope.error=errorMessage;    });    $scope.tags = [];    // Add tags to search from candy list tags    $scope.addTag = function(tag) {      console.log('Click timeline tag: ', tag);      if (!_.contains($scope.tags, tag)) {        $scope.tags.push(tag);      }    };    // Are these even being used? In any case, I refactored them to work    // with new code. NOT TESTED.    $scope.first = function(){      return $scope.timelineValues.index === 0;    };    $scope.last = function(){      return $scope.timelineValues.index ===         $scope.timelineData.timeline.date.length;    };  });