/* global _, async */'use strict';/** * @ngdoc function * @name nasaraCandyBasketApp.controller:CandyListTimeline * @description * Controller of the nasaraCandyBasketApp contains the logic to power the  * candy list in timeline mode. *  * Notes on TimelineJS Slides and Mechanism * ---------------------------------------- *   * To change the slide of the TimelineJS it suffices to change the * state of $scope.timelineValues.index, see {@link * nasaraCandyBasketApp.stateTracker} for the related service details. * This $scope.timelineValues.index as two way bindings with the * angular-timelinejs directive, and *it* will take care of changing * the slides of the instantiates TimelineJS. This value can be force * changed anytime in the controller through $scope.changeSlide * callback, in fact this is how the "go to start" and "go to end" * buttons work. * * TODO - This controller is very similar to the CandyListTimeline controller * and they could both be merged into an Javascript prototype * only adding properties as they differ eliminating  * much code duplication and future errors. */angular.module('nasaraCandyBasketApp')  .controller('CandyListTimeline', function ($scope,                                              $location,                                              $filter,                                              CandyResource,                                              tagsViews,                                              stateTracker,                                              utilities) {    /////////////////////////////////////////////////    // Controller private variables and functions  //    /////////////////////////////////////////////////    // Controller's own private full list of candies. Currently    // filtering is done on the whole list everytime. We can't filter    // on $scope.candies as it is dynamic and candies are lost on each    // search. For the same reason we also have a private    // tagsByCandies handy in the controller    var candies = [];    var tagsByCandies = [];    var filterByTags = $filter('candiesByTags');    var filterByDates = $filter('candiesByDates');    /**     * @ngdoc function     * @name nasaraCandyBasketApp.controller:CandyListTimeline#fetchData     * @description      * is an async function that fetches a fresh copy of     * data from the backend. It fetches both candies and tags data in     * parallel before returning results into a doneFetchingData     * callback. This function is currently execute on start of the     * application and on CRUD updates ($on('model-update')     *     * @param {Function} doneFetchingCallback a callback function used     * to execute some work after fetchData is done     */    var fetchData = function(doneFetchingCallBack) {      async.parallel([        function(callback){          CandyResource.query().$promise.then(function(data) {            candies = data;            callback(null, 'Candies retrieved');          }, function(errorMessage){            $scope.error = errorMessage;            callback(errorMessage, null);          });        },        function(callback){          tagsViews.getTagsByCandies().then(function(response) {            tagsByCandies = response.data.tagsByCandies;            callback(null, 'Tags retrieved');          }, function(errorMessage){            $scope.error = errorMessage;            callback(errorMessage, null);          });        }      ], function(err, results){        // Currently not doing anything with err except logging        if (err) {console.error('Error retrieving data: ', err);}        // Nor are we using results directly        console.log(results);        doneFetchingCallBack();      });    };    /**     * @ngdoc function     * @name nasaraCandyBasketApp.controller:CandyListTimeline#filterData     * @description      * is a synchronous function that merely groups a     * list of repeating operations to avoid duplicate code at various     * locations in the controller. It primarily filters that candy     * data set and can optionally set the slide index depending on     * what called this filtering operation in the first place (e.g. a     * model-update, a slide change, a tag search)     */    var filterData = function() {      var tempCandies = filterByDates(candies,                                       $scope.dateRange[0],                                       $scope.dateRange[1]);      $scope.candies = filterByTags(tempCandies, $scope.tags);      $scope.timelineData = utilities.processTimeline($scope.candies);    };    ///////////////////////////////////////////////////    // Controller scope variables to drive the view  //    ///////////////////////////////////////////////////    // Initialize variables on the scope used to power view dynamically    $scope.candies = [];    $scope.tags = [];    $scope.tagsData = [];    $scope.dateRange = [undefined, undefined];    $scope.timelineValues = stateTracker.state.timelineValues; // i.e. {index: 0}    $scope.slider = {      'options': {        range: true,        stop: function (event, ui) {           console.log('Slider stopped', event);          ui.handle.blur(); // focus interferes with timeline navigation          // Here I thought I could directly use the          // $scope.sliderRange values on two way binding but I am          // missing something and could not get it to work so          // explicitly put the values on their own scope property          $scope.dateRange = ui.values;          $scope.changeSlide(0);                    filterData();          // $apply should be pushed to directive          $scope.$apply();        }      }    };    // Fetch data on controller instantiation, and then assign data on scope     fetchData(function() {      $scope.candies = candies;      $scope.timelineData = utilities.processTimeline($scope.candies);      $scope.tagsData = utilities.getTagsData(tagsByCandies);      $scope.ccsTagStatus = utilities.updateStatusCount(        utilities.getTagsData(tagsByCandies));      // Oldest and newest candies      var range = utilities.getDateRange(candies);      $scope.sliderMin = range[0];      $scope.sliderMax = range[1];      $scope.sliderStep = 24 * 3600 * 1000; // a day in milliseconds      $scope.sliderRange = range;    });        // Listeners    // On model update (CRUD operations) get fresh data    $scope.$on('model-update', function(){      fetchData(function() {        console.log('Slide index on model update: ', $scope.timelineValues.index);        $scope.changeSlide($scope.timelineValues.index);        filterData();      });    });    // Work to perform every time the $scope.tags property changes    $scope.$watchCollection('tags', function(newSearch) {      var newMap = [];      if (newSearch.length > 0) {        tagsByCandies.forEach(function(elem) {          if (_.isEqual(_.intersection(newSearch, elem.tag), newSearch)) {            newMap.push(elem);          }        });      } else {        newMap = tagsByCandies;      }      $scope.changeSlide(0);      filterData();      $scope.tagsData = utilities.getTagsData(newMap);      $scope.ccsTagStatus = utilities.updateStatusCount(        utilities.getTagsData(newMap));    });    // UI Methods    // Used to change the slide without reloading the whole TimelineJS    // andgular-timeline does most of the work, only index need to be changed here    $scope.changeSlide = function (index) {      console.log('Changing slide index to: ', index);      $scope.timelineValues.index = index;    };    // Add tags to search from cloud    $scope.tagOnClickFunction = function(element){      if (!_.contains($scope.tags, element.text)) {        $scope.tags.push(element.text);        // TODO - $apply should really be pushed to relevant directive somehow        $scope.$apply();      }    };    // Add tags to search from candy list table view tags    $scope.addTag = function(tag) {      console.log('Click timeline tag: ', tag);      if (!_.contains($scope.tags, tag)) {        $scope.tags.push(tag);      }    };  });