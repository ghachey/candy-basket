/* global _, async */'use strict';/** * @ngdoc function * @name nasaraCandyBasketApp.controller:CandyListTimeline * @description * # CandyListTimeline * Controller of the nasaraCandyBasketApp contains the logic to power the  * candy list in timeline mode. *  * Notes on TimelineJS Slides and Mechanism * ---------------------------------------- *   * To change the slide of the TimelineJS it suffices to change the * state of $scope.timelineValues.index, see {@link * nasaraCandyBasketApp.stateTracker} for the related service details. * This $scope.timelineValues.index as two way bindings with the * angular-timelinejs directive, and *it* will take care of changing * the slides of the instantiates TimelineJS. This value can be force * changed anytime in the controller through $scope.changeSlide * callback, in fact this is how the "go to start" and "go to end" * buttons work. * * TODO - This controller is very similar to the CandyListTimeline controller * and they could both be merged into an Javascript prototype * only adding properties as they differ eliminating  * much code duplication and future errors. */angular.module('nasaraCandyBasketApp')  .controller('CandyListTimeline', function ($scope,                                              $location,                                              $filter,                                              CandyResource,                                              tagsViews,                                              stateTracker,                                              utilities) {    /////////////////////////////////////////////////    // Controller private variables and functions  //    /////////////////////////////////////////////////    // Controller's own private full list of candies. Currently    // filtering is done on the whole list everytime. We can't filter    // on $scope.candies as it is dynamic and candies are lost on each    // search. For the same reason we also have a private    // tagsByCandies handy in the controller    var candies;    var tagsByCandies = [];    /**     * @ngdoc function     * @name nasaraCandyBasketApp.controller:CandyListTimeline.fetchData     * @description     * # CandyListTimeline.fetchData is an async function that fetches     * a fresh copy of data from the backend. It fetches both candies     * and tags data in parallel before returning results into a     * doneFetchingData callback. This function is currently execute     * on start of the application and on CRUD updates     * ($on('model-update')     *     * @param {Function} doneFetchingCallback a callback function used     * to execute some work after fetchData is done     */    var fetchData = function(doneFetchingCallBack) {      async.parallel([        function(callback){          CandyResource.query().$promise.then(function(data) {            candies = data;            callback(null, 'Candies retrieved');          }, function(errorMessage){            $scope.error = errorMessage;            callback(errorMessage, null);          });        },        function(callback){          tagsViews.getTagsByCandies().then(function(response) {            tagsByCandies = response.data.tagsByCandies;            callback(null, 'Tags retrieved');          }, function(errorMessage){            $scope.error = errorMessage;            callback(errorMessage, null);          });        }      ], function(err, results){        // Currently not doing anything with err except logging        if (err) {console.error('Error retrieving data: ', err);}        // Nor are we using results directly        console.log(results);        doneFetchingCallBack();      });    };    ///////////////////////////////////////////////////    // Controller scope variables to drive the view  //    ///////////////////////////////////////////////////    // Initialize variables on the scope used to power view dynamically    $scope.candies = [];    $scope.tags = [];    $scope.tagsData = [];    $scope.timelineValues = stateTracker.state.timelineValues; // i.e. {index: 0}    // var now               = new Date();    // var ranges            = {    //   'day'   : 1000 * 3600 * 24,    //   'week'  : 1000 * 3600 * 24 * 7,    //   'month' : 1000 * 3600 * 24 * 30,    //   'year'  : 1000 * 3600 * 24 * 365    // };    // Fetch data on controller instantiation, and then assign data on scope     fetchData(function() {      $scope.candies = candies;      $scope.timelineData = utilities.processTimeline($scope.candies);      $scope.tagsData = utilities.getTagsData(tagsByCandies);      $scope.ccsTagStatus = utilities.updateStatusCount(        utilities.getTagsData(tagsByCandies));    });        // On model update (CRUD operations) get fresh data    $scope.$on('model-update', function(){      fetchData(function() {        console.log('Slide index on model update: ', $scope.timelineValues.index);        $scope.candies = $filter('candiesByTags')(candies, $scope.tags);        $scope.timelineData = utilities.processTimeline($scope.candies);        $scope.changeSlide($scope.timelineValues.index);      });    });    // Work to perform every time the $scope.tags property changes    $scope.$watchCollection('tags', function(newSearch) {      var newMap = [];      if (newSearch.length > 0) {        tagsByCandies.forEach(function(elem) {          if (_.isEqual(_.intersection(newSearch, elem.tag), newSearch)) {            newMap.push(elem);          }        });        // Explicit reset to 0 on new non-empty searches        $scope.changeSlide(0);      } else {        newMap = tagsByCandies;      }      $scope.candies = $filter('candiesByTags')(candies, $scope.tags);      $scope.tagsData = utilities.getTagsData(newMap);      $scope.ccsTagStatus = utilities.updateStatusCount(        utilities.getTagsData(newMap));      $scope.timelineData = utilities.processTimeline($scope.candies);    });    // Used to change the slide without reloading the whole TimelineJS    // andgular-timeline does most of the work, only index need to be changed here    $scope.changeSlide = function (index) {      console.log('Changing slide index to: ', index);      $scope.timelineValues.index = index;    };    // These should be set-able, storable via the UI    // Additionally, I'd like us to think about how to set the default $scope.min,    // and $scope.max dates in to the first and last candy dates. Currently, there's    // a double bug, wherein $scope.min is set too far in the past, and $scope.max is    // set to Date.now(), which allows the user to pull up an empty data set    // (and throw an unhandled exception in the bargain).    // $scope.min = now - ranges.year;    // $scope.max = Date.now();    // $scope.step = ranges.day;    // $scope.interval = ranges.month * 2;    // $scope.cutoff = now - (ranges.month * 6); //$scope.min    // $scope.setDates  = function(){    //   var dateVal    = new Date($scope.cutoff);    //   var options = {year: 'numeric', month: 'long', day: 'numeric'};    //   var dateString = dateVal.toLocaleString('en-GB', options);    //   return 'Restrict results to candies created since: <br /><strong>' + dateString + '</strong>';    // };    // $scope.slideStart = function (event, ui){    //   // noop    //   console.log(event, ui);    //   return;    // };    // $scope.slideStop = function (event, ui){    //   console.log(event, ui);    //   var newMap = [];    //   tagsByCandies.forEach(function(elem) {    //     if (_.isEqual(_.intersection($scope.tags, elem.tag), $scope.tags)) {    //       newMap.push(elem);    //     }    //   });    //   if (newMap.length){    //     //$scope.tagsData = utilities.getTagsData(newMap, $scope.cutoff); // reduce cloud    //     //$scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(newMap, $scope.cutoff));    //     $scope.tagsData = utilities.getTagsData(newMap); // reduce cloud    //     $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(newMap));    //     $scope.changeSlide(0);    //     $scope.timelineData = utilities.processTimeline($scope.candies);    //   }    //   else {    //     // $scope.tagsData = utilities.getTagsData(tagsByCandies, $scope.cutoff); // restore cloud    //     // $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsByCandies, $scope.cutoff));    //     $scope.tagsData = utilities.getTagsData(tagsByCandies); // restore cloud    //     $scope.ccsTagStatus = utilities.updateStatusCount(utilities.getTagsData(tagsByCandies));    //   }    // };    // $scope.slideMove = function(event, ui) {    //   console.log('Slide move ui: ', ui);    //   console.log('Slide mode event: ', event);    //   $scope.cutoff = ui.value;    // };    $scope.tagOnClickFunction = function(element){      if (!_.contains($scope.tags, element.text)) {        $scope.tags.push(element.text);        // TODO - $apply should really be pushed to relevant directive somehow        $scope.$apply();      }    };    // Add tags to search from candy list table view tags    $scope.addTag = function(tag) {      console.log('Click timeline tag: ', tag);      if (!_.contains($scope.tags, tag)) {        $scope.tags.push(tag);      }    };  });